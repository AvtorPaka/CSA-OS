.global create_b_array

# Подпрограмма для создания массива B ,состоящего из неубывающих последовательноcтей элементов из переданного массива A
# В случае когда в массиве A 1 элемент - массив B состоит из этого элемента
# В остальных случаях массив B будет состоять из неубывающих последовательностей в массиве A
# Если в A отсутствуют неубывающие последовательности - массив B будет пустым
# Параметры:
# a0 - адрес массива A
# a1 - размер массива A
# a2 - адрес массива B, куда будет вестить запись
# Возвращаемое значение: 
# a0 - адресс созданного массива B
# a1 - размер полученного массива B
.text
create_b_array:
	# Инициализация переменных на стэке
	addi sp sp -8
	sw ra 4(sp)
	sw a2 (sp)
	
	#Проверка размера массива на 1, если _size (a1) = 1, возвращение B = A.
	li t0 1
	bne a1 t0 end_if_size_1
	if_size_1:
		lw t6 (a0)
		sw t6 (a2)
		li t4 1
		j end_alg_loop
	end_if_size_1:
	
	mv t0 a0	# Указатель на предыдущий элемент массива A - A[t5 - 1]
	mv t1 a0	# Указатель на текущий элемент массива A - A[t5]
	addi t1 t1 4
	mv t2 a2	# Текущая позиция для вставки в массив B
	li t3 0		# Индекс потенциального начала подпоследовательности
	li t4 0		# Счетчик количества элементов в массиве B
	li t5 1		# Cчетчик для итераций по массиву A
	li t6 0		# Временное значение для доступа к элементам массива A
	li a6 0		# Временное значение для доступа к элементам массива A
	
	# for (t5 = 1; t5 < a1; t5++) {...}
	for_alg_loop:
	
	lw t6 (t0)
	lw a6 (t1)
	blt a6 t6 else_1
	if_1:	# if A[t5] >= A[t5-1]
		
		addi t5 t5 -1
		bne t5 t3 end_if_2
		if_2: # if t5 - 1 == t3
			lw t6 (t0)
			sw t6 (t2)
			addi t2 t2 4
			addi t4 t4 1
		end_if_2:
		addi t5 t5 1
		
		lw t6 (t1)
		sw t6 (t2)
		addi t2 t2 4
		
		addi t4 t4 1
		b end_1
	else_1:	# A[t5] < A[t5-1]
		mv t3 t5
	end_1:
	
	addi t5 t5 1
	addi t0 t0 4
	addi t1 t1 4
	blt t5 a1 for_alg_loop
	end_alg_loop:
	
	
	# Сохранение возвращаемых значений, воссатновление сохраненых на стеке значений и возврат указателя
	mv a1 t4
	lw a0 (sp)
	lw ra 4(sp)
	addi sp sp 8
	jalr zero 0(ra)