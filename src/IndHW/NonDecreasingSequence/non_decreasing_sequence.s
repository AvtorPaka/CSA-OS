.data
array_a: .space 40
array_b: .space 40
input_size: .asciz "Input array size (1-10): "
input_array_elements: .asciz "Input array data:\n"
output_array_data: .asciz "\nCalculated array B:\n"
empty_array_case: .asciz "Array is empty."
ArraySizeOutOfRangeException: .asciz "ArraySizeOutOfRangeException -> array size must be 1<= _size <= 10"
nxt: .asciz " "

.text
_start:

	# Вызов подпрограммы ввода данных вмассива A
				# Передаваемые параметры:
	la a1 array_a		# a1 адресс массива в памяти, куда пользователь будет записывать данные
	jal ra input_array_data

	# Возвращаемое значение: 
	# a0 -  размер заполненого массива (в случае допустимого значение)
	
	# Вызов подпрограммы формирование массива B по массиву A
				# Передаваемые параметры:
	mv a1 a0		# a1 - размер массива A
	la a0 array_a		# a0 - адрес массива A
	la a2 array_b		# a2 - адрес массива B, куда будет вестить запись
	jal ra create_b_array

	# Возвращаемое значение: 
	# a0 - адресс созданного массива B
	# a1 - размер полученного массива B
	
	# Вызов подпрограммы вывывода элементов массива (в частности элементов массива B)
	# Передаваемые параметры:  
	# a0 - адрес массива, данные которого надо вывести (в a0 уже расположен адресс массива B)
	# a1 - размер массива (в a1 уже расположен размер массива B)
	# a2 - указатель на строку с сообщением вывода (строка для вывода массива B)
	la a2 output_array_data
	jal ra func_output_array_data

	# Возвращаемое значение: 
	# a0 - адресс переданного  массива
	
	j exit_program

# Подпрограмма для ввода размера массива и его наполнения
# Параметры: 
# a1 - адресс массива в памяти, куда пользователь будет записывать данные
# Возвращаемое значение: 
# a0 -  размер заполненого массива (в случае допустимого значение)
input_array_data:
	# Инициализация переменных на стэке
	addi sp sp -12
	sw ra 8(sp)
	sw a1 4(sp)		# Сохранение адресса массива для ввода
	sw zero (sp)	# Место для введенного размера массива
	
	# Ввод пользователем размера массива
	la a0 input_size
	li a7 4
	ecall 
	
	li a7 5
	ecall
	
	sw a0 (sp)	# Сохранение размера массива
	
	# Вызов подпрограммы проверки размера массива
				# Передаваемые параметры:
				# a0 - Размер массива, введенный пользователем (уже в a0 после ecall 5)
	li a1 1			# a1 - нижняя граница размера массива (1)
	li a2 10		# a2 - верхняя граница размера массива (10)
	jal ra check_array_size

	# Возвращаемое значение:
	# a0 - 0 если размер недопустим, 1 в другом случае
	
	# Выброс исключения и завершение работы в случае недопустмого размера (a0 = 0)
	bnez a0 end_b_size
	if_b_size:
		lw ra 8(sp)
		lw a1 4(sp)
		addi sp sp 12
		j throw_ArraySizeOutOfRangeException
	end_b_size:
	
	la a0 input_array_elements
	li a7 4
	ecall
	
	lw t2 (sp)	# Размер массива, введенный ранее пользователем
	lw t0 4(sp)	# Адресс памяти (массива), куда будет происходить запись
	li t1 0		# Счетчик для цикла ввода массива
	
	#for (t1 = 0; t1 < t2; t1++) {...}
	for_fill_loop:
	#Ввод числа пользотвалем
	li a7 5
	ecall
	
	#Запись числа в память(массив)
	sw a0, 0(t0)
	addi t0 t0 4
	addi t1 t1 1
	blt t1 t2 for_fill_loop
	end_fill_loop:

	# Сохранение возвращаемых значений, воссатновление сохраненых на стеке значений и возврат указателя
	lw ra 8(sp)
	lw a1 4(sp)
	lw a0 (sp)
	addi sp sp 12
	jalr zero 0(ra)
	
	
# Подпрограмма для проверки введенного размера массива на корркетность
# Параметры:
# a0 - Размер массива, введенный пользователем
# a1 - нижняя граница размера массива (1)
# a2 - верхняя граница размера массива (10)
# Возвращаемое значение:
# a0 - 0 если размер недопустим, 1 в другом случае
check_array_size:
	# Сохранение ra на стэке
	addi sp sp -4
	sw ra (sp)
	
	blt a0 a1 if_size_error
	ble a0 a2 if_size_ok
	if_size_error:
		li a0 0
		b end_if_size_check
	if_size_ok:
		li a0 1
	end_if_size_check:
	
	# # Воссатновление сохраненых на стеке значений и возврат указателя
	lw ra (sp)
	addi sp sp 4
	jalr zero 0(ra)


# Подпрограмма для создания массива B ,состоящего из неубывающих последовательноcтей элементов из переданного массива A
# В случае когда в массиве A 1 элемент - массив B состоит из этого элемента
# В остальных случаях массив B будет состоять из неубывающих последовательностей в массиве A
# Если в A отсутствуют неубывающие последовательности - массив B будет пустым
# Параметры:
# a0 - адрес массива A
# a1 - размер массива A
# a2 - адрес массива B, куда будет вестить запись
# Возвращаемое значение: 
# a0 - адресс созданного массива B
# a1 - размер полученного массива B
create_b_array:
	# Инициализация переменных на стэке
	addi sp sp -8
	sw ra 4(sp)
	sw a2 (sp)
	
	#Проверка размера массива на 1, если _size (a1) = 1, возвращение B = A.
	li t0 1
	bne a1 t0 end_if_size_1
	if_size_1:
		lw t6 (a0)
		sw t6 (a2)
		li t4 1
		j end_alg_loop
	end_if_size_1:
	
	mv t0 a0	# Указатель на предыдущий элемент массива A - A[t5 - 1]
	mv t1 a0	# Указатель на текущий элемент массива A - A[t5]
	addi t1 t1 4
	mv t2 a2	# Текущая позиция для вставки в массив B
	li t3 0		# Индекс потенциального начала подпоследовательности
	li t4 0		# Счетчик количества элементов в массиве B
	li t5 1		# Cчетчик для итераций по массиву A
	li t6 0		# Временное значение для доступа к элементам массива A
	li a6 0		# Временное значение для доступа к элементам массива A
	
	# for (t5 = 1; t5 < a1; t5++) {...}
	for_alg_loop:
	
	lw t6 (t0)
	lw a6 (t1)
	blt a6 t6 else_1
	if_1:	# if A[t5] >= A[t5-1]
		
		addi t5 t5 -1
		bne t5 t3 end_if_2
		if_2: # if t5 - 1 == t3
			lw t6 (t0)
			sw t6 (t2)
			addi t2 t2 4
			addi t4 t4 1
		end_if_2:
		addi t5 t5 1
		
		lw t6 (t1)
		sw t6 (t2)
		addi t2 t2 4
		
		addi t4 t4 1
		b end_1
	else_1:	# A[t5] < A[t5-1]
		mv t3 t5
	end_1:
	
	addi t5 t5 1
	addi t0 t0 4
	addi t1 t1 4
	blt t5 a1 for_alg_loop
	end_alg_loop:
	
	
	# Сохранение возвращаемых значений, воссатновление сохраненых на стеке значений и возврат указателя
	mv a1 t4
	lw a0 (sp)
	lw ra 4(sp)
	addi sp sp 8
	jalr zero 0(ra)


# Подпрограмма для вывода значение из массива в консоль (в частности полученного в результате работы программы массива B)
# Параметры:  
# a0 - адрес массива, данные которого надо вывести
# a1 - размер массива
# a2 - указатель на строку с сообщением вывода
# Возвращаемое значение: 
# a0 - адресс переданного  массива
func_output_array_data:
	# Инициализация переменных на стэке
	addi sp sp -8
	sw ra 4(sp)
	sw a0 (sp)
	
	mv a0 a2
	li a7 4
	ecall
	
	# Проверка на пустоту массива и вывод соответсвующего сообщения в случае пустоты
	bnez a1 end_if_arr_empty
	if_array_empty:
		la a0 empty_array_case
		li a7 4
		ecall
		j end_output_loop
	end_if_arr_empty:
	
	li t1 0		# Счетчик для цикла ввода массива
	lw t2 0(sp)	# Адресс массива
	
	#for (t1 = 0; t1 < a1; t1++) {...}
	for_output_loop:
	# Вывод элементов массива в консоль
	lw a0 0(t2)
	li a7 1
	ecall
	
	la a0 nxt
	li a7 4
	ecall
	
	addi t2 t2 4
	addi t1 t1 1
	blt t1 a1 for_output_loop
	end_output_loop:
	
	# Сохранение возвращаемых значений, воссатновление сохраненых на стеке значений и возврат указателя
	lw a0 (sp)
	lw ra 4(sp)
	addi sp sp 8
	jalr zero 0(ra)
	
# Метод для выброса исключения и завершения работы программы в случае недопустимого размера массива
throw_ArraySizeOutOfRangeException:
	# Вывод сообщения с исключение в консоль и MessageDialog среды RARS
	la a0 ArraySizeOutOfRangeException
	li a1 0
	li a7 55
	ecall
	
	li a7 4
	ecall
	
	li a7 10
	ecall

# Метод для завершения работы программы
exit_program:
	li a7 10
	ecall
