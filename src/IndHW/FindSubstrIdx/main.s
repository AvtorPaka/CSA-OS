.eqv BUFFER_SIZE 512
.eqv PATH_SIZE 256
.eqv SUBSTRING_SIZE 256
.eqv INTTOSTR_BUFF_SIZE 16

.data
data_buffer: .space BUFFER_SIZE
path_buffer: .space PATH_SIZE
substr_buffer: .space SUBSTRING_SIZE
int_str_buffer: .space INTTOSTR_BUFF_SIZE

.include "macrolib.s"

.global main

.text
main:
	# Вызов подпрограммы (обернутой в макрос) для чтения данных из файла в память на куче с помощью скользящего окна
	# Передаваемые параметры:
	la a0 path_buffer	# %pathB (a0) - буффер для хранения пути к файлу
	li a1 PATH_SIZE		# %pathS (a1) - максимальный размер пути к файлу (размер буффера)
	la a2 data_buffer	# %dataB (a2) - буффер для хранения части текста при считывании
	li a3 BUFFER_SIZE	# %dataS (a3) - максимальный размер буффера данных (512)
	
	load_and_input_from_file_func(a0, a1, a2, a3)
	# Возвращаемое значение:
	# a0 - адрес памяти на хипе, куда были записаны данные
	
	mv s1 a0
	
	# Вызов макроса для ввода подстроки поиска
	# Передаваемые параметры:
	la a0 substr_buffer	# %strbuf (a0) - буффер, куда будет записана строка
	li a1 SUBSTRING_SIZE	# %size (a1) - максимальный размер буффера
	input_substring(a0, a1)
	# Возвращаемое значение: нет
		
	# Вызов подпрограммы (обернутой в макрос) для поиска индексов первого символа для всех вхождений подстроки в строку
	# Передаваемые параметры:
	mv a0 s1		# %data (a0) - область памяти, где расположена строка(текст) , где происходит поиск
	la a1 substr_buffer	# %subtr (a1) - область памяти, где расположена подстрока для поиска вхождений
	find_substr_idx_func(a0, a1)
	# Возвращаемые значения:
	# a0 - адресс полученного массива индексов в куче
	# a1 - размер полученного массива
	
	# Сохранение полученного адреса и размера массива в регистры
	mv s2 a0
	mv s3 a1
	
	# Вызов макроса выбора метода вывода полученных данных
	chose_output()
	# Возвращаемое значение:
	# a0 - 1 при выводе в консоль, 0 при выводе в файл
	
	beqz a0 if_file_output
	if_console_output:
	
		# Вызов подпрограммы (обернутой в макрос) для вывода полученных данных в консоль
		# Передаваемые параметры:
		# %arr (s2) - адресс начала области памяти с массивом 32-битных чисел
		# %size (s3) - размер массива
		upload_to_console_func(s2, s3)
		j end_if_output
	if_file_output:
		blez s3 if_idx_array_empty
		
		# Вызов подпрограммы (обернутой в макрос) для перевода массива 32-битных чисел в строку
		# Передаваемые параметры:
		la a2 int_str_buffer	# %buff (a2) -  адрес начала буффера для временной записи строкового представления числа
		# %arr (s2) - адресс начала области памяти с массивом 32-битных чисел
		# %size (s3) - размер массива
		convert_array_to_string_func(s2, s3, a2)
		
		mv s4 a0
		mv s5 a1
		addi s5 s5 -1		# убираем null-char из длинны строки на вывод в файл
		
		# Вызов подпрограммы (обернутой в макрос) для вывода полученных данных в файл
		# Передаваемые параметры:
		la a0 path_buffer	# %pathB (a0) - буффер для хранения пути к файлу
		li a1 PATH_SIZE		# %pathS (a1) - максимальный размер пути к файлу (размер буффера)
		# %dataB (a2) - адрес памяти на куче где хранится строка для записи в файл
		# %dataS (a3) - размер записываемой строки в байтах
		upload_to_file_input_func(a0, a1, s4, s5)
		
		if_idx_array_empty:
		
	end_if_output:
			
	exit_program()
